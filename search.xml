<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 8）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day8/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>经过上周的刷算法，感觉还是非常有用的，哪怕是作为一个每日盼头，每日目标，也是非常合适的，所以这周继续。仍然是跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E7%AD%89%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E5%92%8C%E5%A4%A7%E8%87%B4%E5%A5%97%E8%B7%AF%E7%9F%A5%E9%81%93%E4%BA%86%EF%BC%8C%E5%86%8D%E5%8E%BB%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，等算法的思维和大致套路知道了，再去刷洛谷。</a></p></blockquote><h3 id="力扣226-翻转二叉树"><a href="#力扣226-翻转二叉树" class="headerlink" title="力扣226 翻转二叉树"></a>力扣226 翻转二叉树</h3><p>前置递归，随便一写竟然ac了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode * left = root-&gt;left, *right = root-&gt;right;</span><br><span class="line">        root-&gt;left = <span class="built_in">invertTree</span>(right);</span><br><span class="line">        root-&gt;right = <span class="built_in">invertTree</span>(left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>东哥的则是更加的想要锻炼算法思维，融入到遍历中去。（前序遍历代表cursor到达该节点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode * root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode *tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><p>自己写没写出来，看的题解觉得很妙，但是呢，对他的三叉树遍历的说法并不认同，我觉得只是逐层遍历，但是我想用迭代，没有办法优雅的实现，但是这个递归确实非常优雅。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Node * node1,Node * node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="literal">NULL</span> || node2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        node1-&gt;next = node2;</span><br><span class="line">        node2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(node1-&gt;left,node1-&gt;right); </span><br><span class="line">        <span class="built_in">traverse</span>(node1-&gt;right,node2-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(node2-&gt;left,node2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>想要自己写，写不出来，很倔，但是还是没能写出来。</p><p>题解的这个很明确，但是我就是觉得不优雅。想要利用后序遍历直接的到尾节点。而不是用while。但是今天不早了，就先不写了。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        TreeNode * left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line"></span><br><span class="line">        TreeNode * tmp = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tmp = tmp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题及就及进 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试图用python提取论文信息</title>
      <link href="/2022/08/01/%E8%AF%95%E5%9B%BE%E7%94%A8python%E6%8F%90%E5%8F%96%E8%AE%BA%E6%96%87%E4%BF%A1%E6%81%AF/"/>
      <url>/2022/08/01/%E8%AF%95%E5%9B%BE%E7%94%A8python%E6%8F%90%E5%8F%96%E8%AE%BA%E6%96%87%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><blockquote><p>需要提取多篇论文（非统一格式的无规则pdf）的作者信息和摘要。其实总量并不大，但是手动复制未免太不geek。</p><p>仅仅是尝试，最终并不一定能成功。摆烂一天了，摆点有意思的。</p></blockquote><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="pdfminer"><a href="#pdfminer" class="headerlink" title="pdfminer"></a>pdfminer</h3><p>选择使用pdfminer进行操作，下面是pdfminer的文档。</p><p><a href="https://buildmedia.readthedocs.org/media/pdf/pdfminer-docs/latest/pdfminer-docs.pdf">https://buildmedia.readthedocs.org/media/pdf/pdfminer-docs/latest/pdfminer-docs.pdf</a></p><p>首先使用pdfminer的工具pdf2txt.py进行测试效果，发现无论是横着的标题还是竖着的标题，都是能直接解析出来的，并且发现，通常只在标题和作者名和摘要都在第一页的前面部分(这部分就不展示了）。我们可以首先提取每篇论文的这部分，然后再细化如何抽取出标题，作者名，摘要。</p><p>那接下来将pdfminer作为一个库而非命令行工具进行使用。</p><p>直接简单摸索一下官方文档里的基本用法。yysy官方文档写的不算太详细，看完也不知道怎么获得第一页的文本。类非常多，属实有点繁琐。在网上摸了一通，觉得好像并不好用。换</p><h3 id="pypdf2"><a href="#pypdf2" class="headerlink" title="pypdf2"></a>pypdf2</h3><p>麻了，中文乱码</p><h3 id="pdfplumber"><a href="#pdfplumber" class="headerlink" title="pdfplumber"></a>pdfplumber</h3><p>这才是人性化的pdf读取工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfplumber</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> pdfplumber.<span class="built_in">open</span>(<span class="string">&quot;/home/blues/Desktop/论文/工/水利/The visual analysis on the resea_..._China based on the knowledge map.pdf&quot;</span>) <span class="keyword">as</span> pdf:</span><br><span class="line">    first_page = pdf.pages[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(first_page.extract_text())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简简单单一点代码就能够读取一页的文字。</p><p>那么现在先随便拿一个文件夹测试一下。对文件夹中的每一个文件进行遍历，并且提取出包含作者摘要关键词的一页（有的论文在第二页），并且存储到同名txt文件下。</p><p>一点点蹩脚的脚本，但是已经基本ok。其中也包含了两个异常处理，分别是没有找到摘要页，打不开文件，并且也记录到了相应的文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfplumber</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">f1 = <span class="built_in">open</span>(<span class="string">&quot;no content.txt&quot;</span>, <span class="string">&quot;wt+&quot;</span>)</span><br><span class="line">f2 = <span class="built_in">open</span>(<span class="string">&quot;no abstract.txt&quot;</span>, <span class="string">&quot;wt+&quot;</span>)</span><br><span class="line">base = <span class="string">&#x27;/home/blues/Desktop/论文/&#x27;</span></span><br><span class="line"><span class="keyword">for</span> root, <span class="built_in">dir</span>, files <span class="keyword">in</span> os.walk(base):</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> pdfplumber.<span class="built_in">open</span>(root + <span class="string">&#x27;/&#x27;</span> + one) <span class="keyword">as</span> pdf:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                content = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; <span class="number">3</span>:  <span class="comment"># 一般三页已经是摘要了</span></span><br><span class="line">                    content = <span class="built_in">str</span>(pdf.pages[i].extract_text())</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&#x27;摘要&#x27;</span> <span class="keyword">in</span> content <span class="keyword">or</span> <span class="string">&#x27;摘 要&#x27;</span> <span class="keyword">in</span> content <span class="keyword">or</span> <span class="string">&#x27;Abstract&#x27;</span> <span class="keyword">in</span> content <span class="keyword">or</span> <span class="string">&#x27;摘  要&#x27;</span> <span class="keyword">in</span> content:</span><br><span class="line">                        flag = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;abstract not found in &#x27;</span> + one)</span><br><span class="line">                    f2.write(root+<span class="string">&#x27;/&#x27;</span>+one+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(one[:-<span class="number">4</span>] + <span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(content)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(root + <span class="string">&#x27;/&#x27;</span> + one)</span><br><span class="line">            f1.write(root+<span class="string">&#x27;/&#x27;</span>+one+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f1.close()</span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure><p>此时得到了相应的包含摘要的一页，接下来通过匹配相关的内容获得，作者，摘要，关键词。</p>]]></content>
      
      
      <categories>
          
          <category> touch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 9）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day9/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E7%AD%89%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E5%92%8C%E5%A4%A7%E8%87%B4%E5%A5%97%E8%B7%AF%E7%9F%A5%E9%81%93%E4%BA%86%EF%BC%8C%E5%86%8D%E5%8E%BB%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，等算法的思维和大致套路知道了，再去刷洛谷。</a></p></blockquote><h3 id="力扣-114-二叉树展开为链表"><a href="#力扣-114-二叉树展开为链表" class="headerlink" title="力扣 114 二叉树展开为链表"></a>力扣 114 二叉树展开为链表</h3><p>对昨晚的这个题目有执念。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traverse</span><span class="params">(TreeNode * root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode * left = <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        TreeNode *right = <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            temp = temp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就是说，第一反应还是被题解影响了，其实和昨天的大差不差。今天想要做的其实是能够返回值是尾节点。思考了下，尾其实不现实，因为没法在离开一个节点时就知道它的尾是哪个节点。</p><p>力扣题解里则是利用了结论，左子树的最右节点将会是右子树的父节点。但是个人感觉东哥的递归更符合人类的思维。</p><h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><p>首先这个题肯定要学会vector的切片操作，方便进行递归。当然也可以通过维护下标实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123; <span class="comment">//左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(right == left) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> max_idx;</span><br><span class="line">        <span class="type">int</span> max_val = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max_val)&#123;</span><br><span class="line">                max_val = nums[i];</span><br><span class="line">                max_idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(max_val);</span><br><span class="line">        root-&gt;left = <span class="built_in">func</span>(nums,left,max_idx);</span><br><span class="line">        root-&gt;right = <span class="built_in">func</span>(nums,max_idx + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过维护下标实现的伪切片成功ac了。直接正常的递归得到了。力扣题解也是直接递归做的。</p><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>剑指offer上写过，看能不能直接ac。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode * <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;preorder,<span class="type">int</span> a, <span class="type">int</span> b, vector&lt;<span class="type">int</span>&gt;&amp;inorder, <span class="type">int</span> c, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(b == a || c == d)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> root_val = preorder[a];</span><br><span class="line">        <span class="type">int</span> root_idx=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = c; i&lt;d ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == root_val)&#123;</span><br><span class="line">                root_idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">func</span>(preorder,a+<span class="number">1</span>,root_idx - c + a + <span class="number">1</span> ,inorder, c , root_idx);</span><br><span class="line">        root-&gt;right = <span class="built_in">func</span>(preorder, root_idx - c + <span class="number">1</span> + a, b, inorder, root_idx + <span class="number">1</span> , d);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>(),inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过简单的debug以后ac了。因为有一个找根节点的操作，所以还可以用哈系表优化一下。如下则是哈系表的优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function">TreeNode * <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;preorder,<span class="type">int</span> a, <span class="type">int</span> b, vector&lt;<span class="type">int</span>&gt;&amp;inorder, <span class="type">int</span> c, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(b == a || c == d)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> root_val = preorder[a];</span><br><span class="line">        <span class="type">int</span> root_idx= mp[root_val];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root_val);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">func</span>(preorder,a+<span class="number">1</span>,root_idx - c + a + <span class="number">1</span> ,inorder, c , root_idx);</span><br><span class="line">        root-&gt;right = <span class="built_in">func</span>(preorder, root_idx - c + <span class="number">1</span> + a, b, inorder, root_idx + <span class="number">1</span> , d);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>(),inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>和上面一题一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;inorder, <span class="type">int</span> a, <span class="type">int</span> b, vector&lt;<span class="type">int</span>&gt;&amp; postorder,<span class="type">int</span> c, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b || c == d)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> val_root = postorder[d<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> idx_root = mp[val_root];</span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val_root);</span><br><span class="line">        root-&gt;left = <span class="built_in">func</span>(inorder,a,idx_root,postorder,c,idx_root-a+c);</span><br><span class="line">        root-&gt;right = <span class="built_in">func</span>(inorder,idx_root+<span class="number">1</span>,b,postorder,idx_root-a+c,d<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>(),postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一遍过了属于是。</p><h3 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h3><p>我承认这个题需要再思考一波。</p><p>不知道为什么就是写不对， 先暂时放放，看别的题，先把错误的答案贴上来，后续看问题在哪。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;preorder,<span class="type">int</span> a, <span class="type">int</span> b, vector&lt;<span class="type">int</span>&gt; postorder,<span class="type">int</span> c, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=b||c&gt;=d) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[a]);</span><br><span class="line">        <span class="type">int</span> left = preorder[a + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> idx = mp[left];</span><br><span class="line">        <span class="type">int</span> leftSize = idx - a + <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">func</span>(preorder,a+<span class="number">1</span>,a+<span class="number">1</span>+leftSize,postorder,c, idx+<span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">func</span>(preorder,a+<span class="number">1</span>+leftSize,b,postorder,idx+<span class="number">1</span>,d);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; preorder.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp[preorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>(),postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><p>这题要求对字符串进行操作，所以非常合理的，对C++的字符串操作进行学习。</p><p>下面的链接中对字符串操作的大部分内容进行了整理。</p><p><a href="https://blog.csdn.net/zuzhiang/article/details/78155112">https://blog.csdn.net/zuzhiang/article/details/78155112</a></p><p>其中没有提及的是substr函数用于对字符串取切片。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1231231&quot;</span>;</span><br><span class="line">cout&lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>从0开始的2个字符组成的字符串，原字符串不被改变。</p><p>使用先序遍历生成字符串是很快的，但是从字符串回到树，我卡住了，我是试图像之前一样对字符串进行分割，分出左子树和右子树，但是我却没有办法获得左子树和右子树的节点数目，故也就无法分割，查看题解发现，他不分割，直接正常顺序遍历，遍历到两个##则自然就会去构造右子树。</p><p>然后看了多个题解，都是需要用c++完成一个split函数的（忽略那种高级的istingstream了）。</p><p>直接开写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        s += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode * <span class="title">func</span><span class="params">(vector&lt;string&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= arr.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[a] == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">            a++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(arr[a]));</span><br><span class="line">        a++;</span><br><span class="line">        root-&gt;left = <span class="built_in">func</span>(arr);</span><br><span class="line">        root-&gt;right =  <span class="built_in">func</span>(arr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; arr; </span><br><span class="line">        string temp;</span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">length</span>(); i++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(data[i] != <span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                temp += data[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                temp.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参照着题解，艰难写下。不过这个是前序遍历的，非常巧妙的直接自然的就构造好了，不用自己区分左右子树。</p><h3 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h3><p>看完题目内心毫无波动。根本不会写。</p><p>看完题解，思路是将每个节点的子树序列化，然后存哈希表。</p><p>这个输出看的我云里雾里。</p><p>虽然思路没想到，但是实现起来非常迅速。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; mp; <span class="comment">// 先暂时用这个</span></span><br><span class="line">    vector&lt;TreeNode*&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">traverse</span><span class="params">(TreeNode * root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string s = <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        s += <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        s += <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(mp[s] == <span class="number">1</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        mp[s]++;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树与归并排序"><a href="#树与归并排序" class="headerlink" title="树与归并排序"></a>树与归并排序</h2><h3 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></h3><p>进行一个归并排序的写。麻了一个merge卡了很久，这个左开右闭的区间base case和count的初始值错了。</p><p>写递归一定要注意啊。！！！md</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums , <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; left &lt;&lt; &#x27;,&#x27; &lt;&lt; right&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(left == right || left == right - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums,left,mid);</span><br><span class="line">        <span class="built_in">sort</span>(nums,mid,right);</span><br><span class="line">        <span class="built_in">merge</span>(nums,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        temp.<span class="built_in">assign</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = left ,j = mid;</span><br><span class="line">        <span class="type">int</span> count = left;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;mid &amp;&amp; j &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i] &gt; temp[j])&#123;</span><br><span class="line">                nums[count++] = temp[j++];       </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[count++] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;mid)&#123;</span><br><span class="line">            nums[count++] = temp[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题及就及进 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 7）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day7/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为算法题实在太弱了，以前都还多少能写点算法题，现在就是纯纯的大废物一个。所以继续开始算法题的复健，大致分为两条线，一边是跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E5%8F%A6%E4%B8%80%E8%BE%B9%E6%98%AF%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，另一边是刷洛谷。</a></p><p>暂时分配时间为1周。看看效果如何（现在是5月1日，周日）。</p><p>今天五一劳动节，开玩了，简单刷几道吧。</p></blockquote><h2 id="5-2补五一劳动节"><a href="#5-2补五一劳动节" class="headerlink" title="5.2补五一劳动节"></a>5.2补五一劳动节</h2><p>之前已经把二分法的基本操作都过了，现在开始别的数组类题目。</p><h3 id="870-优势洗牌"><a href="#870-优势洗牌" class="headerlink" title="870. 优势洗牌"></a><a href="https://leetcode-cn.com/problems/advantage-shuffle/">870. 优势洗牌</a></h3><p>看到的第一反应其实是回溯，因为类似于之前小学期写的正方形。 然后看完题解发现这个是需要动脑子来降低时间复杂度的，这个决策的模型就是当我同等级的能和他比时，我就比，否则我就拿我最差的和他送。但是这个要返回一个数组，我觉得构造很麻烦，这题就不写了。。。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>关于一棵二叉树的前中后序遍历的理解，是对一个节点的不同时期进行处理。</p><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>大废物好像并不会写这个题。脑子里只有进行一波dfs或者进行一波bfs来获取一棵树的深度，理论上来说，这应该也是合理的想法，现在写一个dfs的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt; max)&#123;</span><br><span class="line">            max = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left,depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right,depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单优化一下代码长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)  <span class="keyword">return</span> ;</span><br><span class="line">        ans = <span class="built_in">max</span>(depth,ans);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,depth + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>立刻变的短小了。</p><p>感觉这种dfs本质就是遍历，并且是前序遍历。然后再写一个bfs。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123; </span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                &#125; </span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之前以为bfs就需要进行一个深度的记录，但是这里直接每次都把同一深度的都pop出来，所以就可以只用一个变量记录。</p><h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>这个题，第一反应是floyd算法直接当作无向图跑一遍，然后走一遍数组找到最大值。但是总感觉这样有点大炮打蚊子。所以还要再思考一下。</p><p>看题解知道，每一条二叉树直径的长度就是一个节点左右子树的最大深度之和，这个确实非常容易证明，但是刚才没有想到（感觉差一点就要想到了）</p><p>这里直接进行一波猜测，那就遍历每一个节点，获取每一个节点的左右子树最大深度和，然后更新一个全局变量。</p><p>救命，我没法写出，获取每一个节点的左右子树深度和的代码。。。。我太菜了</p><p>看着题解写出来的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightMax = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> d = leftMax+ rightMax;</span><br><span class="line">        ans = <span class="built_in">max</span>(d,ans);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个肉眼可见的速度不会太快。在此之前，我从未想过还可以用两个递归，前序遍历二叉树的时候，又继续递归求深度，我以为这个是在一次递归中完成的。</p><p>继续往下看，发现是可以用一个递归实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(left+right,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">maxDepth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实我之前实现的已经很像了，当时就是返回值不对。一个递归的速度，远远快于两个递归了。</p>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础练习</title>
      <link href="/2022/08/01/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2022/08/01/js%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为之前的算法题都是用的c等写的，此处试图变成js的形状。</p></blockquote><p>刷来自牛客上的50道题</p><p><a href="https://www.nowcoder.com/ta/js-assessment">https://www.nowcoder.com/ta/js-assessment</a></p><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 2], 2</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 4]</span><br></pre></td></tr></table></figure><p>C的形状</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">remove</span><span class="params">(arr, item)</span> &#123;</span><br><span class="line">    let a = []</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">0</span>; i&lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]!=item)&#123;</span><br><span class="line">            a.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到的js的版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value === item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处用到了Array.prototype.filter()</p><p><code>filter()</code> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素</p><p>详见下面的链接</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter</a></p><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果数组返回</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 3, 4, 2, 2], 2</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 4]</span><br></pre></td></tr></table></figure><p>c的形状</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">removeWithoutCopy</span><span class="params">(arr, item)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">0</span> ; i&lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == item)&#123;</span><br><span class="line">            arr.splice(i,<span class="number">1</span>)</span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里c不起来，必然要使用js自带的轮子，此处用到一个splice</p><blockquote><p>splice(index,len,[item])   注释：改变原始数组。</p><p>splice有3个参数，它也可以用来替换&#x2F;删除&#x2F;添加数组内某一个或者几个值</p><p>index:数组开始下标     len: 替换&#x2F;删除的长度    item:替换的值，删除操作的话 item为空</p></blockquote><h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>在数组 arr 末尾添加元素 item。结果返回新的数组。</p><p>注意：不要直接修改数组 arr!!!</p><h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4],  10</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 10]</span><br></pre></td></tr></table></figure><p>这应该就是为了让我熟悉不同的js函数的，就不用c的形状了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">append</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [...arr]</span><br><span class="line">    a.<span class="title function_">push</span>(item)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个是我自己学到的（不是那么深的）深拷贝，然后再添加一个值。</p><p>不过看到还有很多方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">append</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">     <span class="comment">//复制数组</span></span><br><span class="line">     <span class="keyword">var</span> a = arr.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="comment">//添加元素</span></span><br><span class="line">     a.<span class="title function_">push</span>(item);</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">append</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> result = arr.<span class="title function_">concat</span>(item);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意slice和splice，slice是返回一个新的数组，浅拷贝（对象等只会拷贝引用）</p><h1 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h1><p>略</p><h1 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组</p><h2 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4], 10</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">prepend</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [item].<span class="title function_">concat</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prepend</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = arr.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">    a.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">0</span>,item)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h1><p>略</p><h1 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h1><p>略</p><h1 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h1><p>都是考察slice和splice的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">arr, item, index</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = arr.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">    a.<span class="title function_">splice</span>(index,<span class="number">0</span>,item)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>统计数组 arr 中值等于 item 的元素出现的次数</p><h2 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 4, 4, 3, 4, 3], 4</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>来点js的形状, 主要是用了一个foreach，foreach了解一波。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(e == item)&#123;</span><br><span class="line">          cnt ++</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> (e == item)</span><br><span class="line">    &#125;).<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用reduce来进行</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev, curr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curr === item ? prev+<span class="number">1</span> : prev;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>找出数组 arr 中重复出现过的元素（不用考虑返回顺序）</p><h2 id="示例1-5"><a href="#示例1-5" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 4, 4, 3, 3, 1, 5, 3]</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 4]</span><br></pre></td></tr></table></figure><p>第一思路是，先排序，然后就好找了，然后正常遍历。或者是用哈系表的思想。</p><p>那这里学习一下js的排序相关。</p><p>js中的排序是非常特殊的，sort函数默认按照字符串序。而有时我们想要的应该是数值大小顺序。所以就要用到sort的参数，可以以一个函数为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">duplicates</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">let</span> a = []</span><br><span class="line">    arr.<span class="title function_">sort</span>(compare)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> last = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> last_in = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;  i &lt; arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == last &amp;&amp; arr[i] !=last_in)&#123;</span><br><span class="line">            a.<span class="title function_">push</span>(arr[i])</span><br><span class="line">            last_in = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        last = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用很c的方式写了一个先排序后查找的。</p><p>然后此处也可以用js的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">duplicates</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a=arr.<span class="title function_">sort</span>(),b=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i-<span class="number">1</span>] &amp;&amp; b.<span class="title function_">indexOf</span>(a[i])==-<span class="number">1</span>) b.<span class="title function_">push</span>(a[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;<span class="comment">//先排序，如果后一个与前一个相等且未保存，则保存。</span></span><br></pre></td></tr></table></figure><p>再写一个很c的哈系表的吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">duplicates</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [], b =[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b[arr[i]])&#123;</span><br><span class="line">            b[arr[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[arr[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    b.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e,index</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            a.<span class="title function_">push</span>(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个半借鉴了已有的代码，不过这引出了一个问题， 就是js中的arr，竟然是可以下标不连续的，就是有一些没有赋值过的位置，也可以存值。</p><p><img src="/home/blues/.config/Typora/typora-user-images/image-20220423143352575.png" alt="image-20220423143352575"></p><p>就比如这里的empty item，就非常神奇，所以了解一下js的empty item的机制。</p><p>没有找到他的机制，只是知道他可以这么去做，也不知道内存占用是什么样的。先这样吧，我暂时不打算去深入了解。</p><h1 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h1><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组</p><h2 id="示例1-6"><a href="#示例1-6" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16]</span><br></pre></td></tr></table></figure><p>这里直接遍历求和即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = []</span><br><span class="line">    arr.<span class="title function_">forEach</span>( <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        a.<span class="title function_">push</span>(e*e)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也看到有人用map函数</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></p><p><code>**map()**</code> 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</p><h1 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h1><p>略</p><h1 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h1><h2 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h2><p>给定的 js 代码中存在全局变量，请修复</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>在Javascript语言中，声明变量使用的都是关键字var，如果不使用var而直接声明变量，则该变量为全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">globals</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> myObject = &#123;   <span class="comment">// let 或者 var</span></span><br><span class="line">      name : <span class="string">&#x27;Jory&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第十五题-正确的使用-parseInt"><a href="#第十五题-正确的使用-parseInt" class="headerlink" title="第十五题  正确的使用 parseInt"></a>第十五题  正确的使用 parseInt</h1><h2 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h2><p>修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parse2Int</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例1-7"><a href="#示例1-7" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;12&#x27;</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;12px&#x27;</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;0x12&#x27;</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parse2Int</span>(<span class="params">num</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(num,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10进制 遇到不是 数字 直接 无视</p><h1 id="第十六题"><a href="#第十六题" class="headerlink" title="第十六题"></a>第十六题</h1><p>略</p><h1 id="第十七题"><a href="#第十七题" class="headerlink" title="第十七题"></a>第十七题</h1><h2 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h2><p>实现一个打点计时器，要求<br>1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 1<br>2、返回的对象中需要包含一个 cancel 方法，用于停止定时操作<br>3、第一个数需要立即输出。</p><p>这个题根本不会写，但是大体上感觉是setInterval，和setTimeout，这种还是比较常见的函数，所以了解一波。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/setInterval">https://developer.mozilla.org/en-US/docs/Web/API/setInterval</a></p><p>就是每次等一段时间以后再执行函数</p><p>setTimeout</p><p><a href="https://www.w3schools.com/jsref/met_win_settimeout.asp">https://www.w3schools.com/jsref/met_win_settimeout.asp</a></p><p>这个是等时间结束后执行一次（只一次）</p><p>从网上偷来的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">  <span class="comment">//立即输出第一个值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(start++);</span><br><span class="line">     <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(start &lt;= end)&#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(start++);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//返回一个对象</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         cancel : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>这里用到一个clearInterval 清除计时器</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/clearInterval">https://developer.mozilla.org/en-US/docs/Web/API/clearInterval</a></p><h1 id="第十八题"><a href="#第十八题" class="headerlink" title="第十八题"></a>第十八题</h1><h2 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a>描述</h2><p>实现 fizzBuzz 函数，参数 num 与返回值的关系如下：<br>1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz<br>2、如果 num 能被 3 整除，返回字符串 fizz<br>3、如果 num 能被 5 整除，返回字符串 buzz<br>4、如果参数为空或者不是 Number 类型，返回 false<br>5、其余情况，返回参数 num</p><h2 id="示例1-8"><a href="#示例1-8" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fizzbuzz</span><br></pre></td></tr></table></figure><p>这个是非常简单的if语句就能够完成的任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fizzBuzz</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="literal">undefined</span> || <span class="built_in">parseInt</span>(num,<span class="number">10</span>) != num)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num %<span class="number">3</span> == <span class="number">0</span> &amp;&amp; num % <span class="number">5</span> ==<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fizzbuzz&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num % <span class="number">3</span> ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fizz&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;buzz&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是一个判断是否是数字，可以</p><ul><li>parseInt 后是否是自己</li><li>isNaN(num) </li><li>typeof(num) !&#x3D; “number”</li></ul><h1 id="第十九题"><a href="#第十九题" class="headerlink" title="第十九题"></a>第十九题</h1><h2 id="描述-11"><a href="#描述-11" class="headerlink" title="描述"></a>描述</h2><p>将数组 arr 中的元素作为调用函数 fn 的参数</p><h2 id="示例1-9"><a href="#示例1-9" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (greeting, name, punctuation) &#123;return greeting + &#x27;, &#x27; + name + (punctuation || &#x27;!&#x27;);&#125;, [&#x27;Hello&#x27;, &#x27;Ellie&#x27;, &#x27;!&#x27;]</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Ellie!</span><br></pre></td></tr></table></figure><p>调用函数可以使用call或者apply这两个方法，区别在于call需要将传递给函数的参数明确写出来，是多少参数就需要写多少参数。而apply则将传递给函数的参数放入一个数组中，传入参数数组即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">argsAsArray</span>(<span class="params">fn, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学到了学到了</p><h1 id="第二十题"><a href="#第二十题" class="headerlink" title="第二十题"></a>第二十题</h1><h2 id="描述-12"><a href="#描述-12" class="headerlink" title="描述"></a>描述</h2><p>将函数 fn 的执行上下文改为 obj 对象</p><h2 id="示例1-10"><a href="#示例1-10" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function () &#123;return this.greeting + &#x27;, &#x27; + this.name + &#x27;!!!&#x27;;&#125;, &#123;greeting: &#x27;Hello&#x27;, name: &#x27;Rebecca&#x27;&#125;</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Rebecca!!!</span><br></pre></td></tr></table></figure><p>在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">speak</span>(<span class="params">fn, obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="title function_">apply</span>(obj, obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>又学到了又学到了。</p><h1 id="第二十一题-返回函数"><a href="#第二十一题-返回函数" class="headerlink" title="第二十一题 返回函数"></a>第二十一题 返回函数</h1><h2 id="描述-13"><a href="#描述-13" class="headerlink" title="描述"></a>描述</h2><p>实现函数 functionFunction，调用之后满足如下条件：<br>1、返回值为一个函数 f<br>2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ‘, ‘<br>3、所有函数的参数数量为 1，且均为 String 类型</p><h2 id="示例1-11"><a href="#示例1-11" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionFunction(&#x27;Hello&#x27;)(&#x27;world&#x27;)</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionFunction</span>(<span class="params">str</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> f = <span class="keyword">function</span>(<span class="params">s</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> str + <span class="string">&quot;, &quot;</span>+ s</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题本质上应该还算是个作用域的题目，只要知道了作用域的相关规则， 这种题就没啥事儿。</p><h1 id="第二十二题"><a href="#第二十二题" class="headerlink" title="第二十二题"></a>第二十二题</h1><h2 id="描述-14"><a href="#描述-14" class="headerlink" title="描述"></a>描述</h2><p>实现函数 makeClosures，调用之后满足如下条件：<br>1、返回一个函数数组 result，长度与 arr 相同</p><p>2、运行 result 中第 i 个函数，即 result<a href="">i</a>，结果与 fn(arr[i]) 相同</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params">x</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> x * x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">makeClosures</span>(arr,fn);</span><br><span class="line">(result[<span class="number">1</span>]() === <span class="number">4</span>) === (<span class="title function_">fn</span>(arr[<span class="number">1</span>]) === <span class="number">4</span>) === <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这是一个讲闭包的题</p><p>回顾一下闭包的定义</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeClosures</span>(<span class="params">arr, fn</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="title function_">fn</span>(e)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二十三题"><a href="#第二十三题" class="headerlink" title="第二十三题"></a>第二十三题</h1><h2 id="描述-15"><a href="#描述-15" class="headerlink" title="描述"></a>描述</h2><p>已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：<br>1、返回一个函数 result，该函数接受一个参数<br>2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致</p><h2 id="示例1-12"><a href="#示例1-12" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayIt = function(greeting, name, punctuation) &#123;     return greeting + &#x27;, &#x27; + name + (punctuation || &#x27;!&#x27;); &#125;;  partial(sayIt, &#x27;Hello&#x27;, &#x27;Ellie&#x27;)(&#x27;!!!&#x27;);</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Ellie!!!</span><br></pre></td></tr></table></figure><p>直接写了一波闭包就ac了， 看评论里似乎还可以用apply，bind等函数，暂时我就不管啦，明天重新整理知识点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">partial</span>(<span class="params">fn, str1, str2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">str3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(str1,str2,str3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二十四题"><a href="#第二十四题" class="headerlink" title="第二十四题"></a>第二十四题</h1><h2 id="描述-16"><a href="#描述-16" class="headerlink" title="描述"></a>描述</h2><p>函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。</p><h2 id="示例1-13"><a href="#示例1-13" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>不是很明白js的变參函数的实现方法。只能看题解了。</p><p>题解说的很清楚，调用函数时，有一个变量叫做arguments，内部包含着所有的参数，也可以通过arguments.length 获得数量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useArguments</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="variable language_">arguments</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        sum += <span class="variable language_">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是「希留」大佬的解释</p><p>本题考查的是对于arguments的使用，arguments能获得函数对象传入的参数组，类似与一个数组，能够通过length获取参数个数，能通过下标获取该位置的参数，但是它不能使用forEach等方法。本题先通过arguments.length获得参数个数，然后循环求和，得出结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useArguments</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   因为参数数量不定，可以先获取参数个数arguments.length</span></span><br><span class="line"><span class="comment">   然后循环求值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//声明一个变量保存最终结果</span></span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//循环求值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      sum += <span class="variable language_">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="第二十五题"><a href="#第二十五题" class="headerlink" title="第二十五题"></a>第二十五题</h1><h2 id="描述-17"><a href="#描述-17" class="headerlink" title="描述"></a>描述</h2><p>实现函数 callIt，调用之后满足如下条件<br>1、返回的结果为调用 fn 之后的结果<br>2、fn 的调用参数为 callIt 的第一个参数之后的全部参数</p><h2 id="示例1-14"><a href="#示例1-14" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p>这道题主要是考察arguments不是真正的数组，所以不能直接调用slice得到参数，所以需要先构造一个数组，然后使用apply和slice即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callIt</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Array.prototype.slice.call 是之前不知道的，了解之</p><p>发现就是将类数组的格式转化为数组，暂时不深究。</p><h1 id="第二十六题"><a href="#第二十六题" class="headerlink" title="第二十六题"></a>第二十六题</h1><h2 id="描述-18"><a href="#描述-18" class="headerlink" title="描述"></a>描述</h2><p>实现函数 partialUsingArguments，调用之后满足如下条件：<br>1、返回一个函数 result<br>2、调用 result 之后，返回的结果与调用函数 fn 的结果一致<br>3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数</p><h2 id="示例1-15"><a href="#示例1-15" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p>这个题是返回闭包并且要获得inner的所有参数，所以我又不会了，写了又是错。</p><p>emmm看完题解以后发现其实第二个函数的仍然是arguements</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">partialUsingArguments</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> args2 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return fn.apply(null,args.concat(args2))</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>,args.<span class="title function_">concat</span>(args2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里有一个小坑，他没有说这个func其实是被变参调用的，导致我一看一开始是使用的fn(args.concat(args2)) </p><p>但是因为是变参的，所以要apply.</p><h1 id="第二十七题"><a href="#第二十七题" class="headerlink" title="第二十七题"></a>第二十七题</h1><p>不是很懂科里化的定义，但是直接多重闭包过了，不想深究，此处略。</p><h1 id="第二十八，二十九题"><a href="#第二十八，二十九题" class="headerlink" title="第二十八，二十九题"></a>第二十八，二十九题</h1><p>略</p><h1 id="第三十题"><a href="#第三十题" class="headerlink" title="第三十题"></a>第三十题</h1><h2 id="描述-19"><a href="#描述-19" class="headerlink" title="描述"></a>描述</h2><p>完成函数 createModule，调用之后满足如下要求：<br>1、返回一个对象<br>2、对象的 greeting 属性值等于 str1， name 属性值等于 str2<br>3、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ‘, ‘ + name属性值</p><p>显然是要开始灌输面向对象的思想了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createModule</span>(<span class="params">str1, str2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;greeting&#x27;</span>:str1,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>:str2,</span><br><span class="line">        <span class="attr">sayIt</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">greeting</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三十一题"><a href="#第三十一题" class="headerlink" title="第三十一题"></a>第三十一题</h1><h2 id="描述-20"><a href="#描述-20" class="headerlink" title="描述"></a>描述</h2><p>获取数字 num 二进制形式第 bit 位的值。注意：<br>1、bit 从 1 开始<br>2、返回 0 或 1<br>3、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1</p><h2 id="示例1-16"><a href="#示例1-16" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">128, 8</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>位运算，这个在c语言中可再熟悉不过了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">valueAtBit</span>(<span class="params">num, bit</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (num &gt;&gt; (bit - <span class="number">1</span> )) &amp; <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是看后面的题目感觉这个似乎是想要考察js中的进制转换。</p><p>那么进制转换的话，先转化为字符串，然后找值咯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">valueAtBit</span>(<span class="params">num, bit</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> numStr=(num).<span class="title function_">toString</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> numStr[numStr.<span class="property">length</span>-bit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三十二题"><a href="#第三十二题" class="headerlink" title="第三十二题"></a>第三十二题</h1><h2 id="描述-21"><a href="#描述-21" class="headerlink" title="描述"></a>描述</h2><p>给定二进制字符串，将其换算成对应的十进制数字</p><h2 id="示例1-17"><a href="#示例1-17" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;11000000&#x27;</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192</span><br></pre></td></tr></table></figure><p>这个直接用parseInt可以实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">base10</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(str,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不知道这个的话，其实也可以循环一位一位的加，此处就不写了。</p><h1 id="第三十三题"><a href="#第三十三题" class="headerlink" title="第三十三题"></a>第三十三题</h1><h2 id="描述-22"><a href="#描述-22" class="headerlink" title="描述"></a>描述</h2><p>将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。</p><h2 id="示例1-18"><a href="#示例1-18" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01000001</span><br></pre></td></tr></table></figure><p>显然使用parseInt和toString即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convertToBinary</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">parseInt</span>(num).<span class="title function_">toString</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;0&quot;</span>.<span class="title function_">repeat</span>(<span class="number">8</span>-a.<span class="property">length</span>)).<span class="title function_">concat</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三十四题"><a href="#第三十四题" class="headerlink" title="第三十四题"></a>第三十四题</h1><h2 id="描述-23"><a href="#描述-23" class="headerlink" title="描述"></a>描述</h2><p>求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题</p><h2 id="示例1-19"><a href="#示例1-19" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3, 0.0001</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0003</span><br></pre></td></tr></table></figure><p>低精度的情况下，3 × 0.0001 &#x3D; 0.30000000000000004</p><p>所以不能直接a  * b</p><p>看题解。主要两种解法，一种是涉及toFixed函数</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed</a></p><p>toFixed就是保留多少位小数，但是显然这个是比较粗糙的。未必能解决问题。</p><p>另一种则是先将其转化为字符串，然后判断小数的位数，精度大的作为精度，然后相乘，然后toFixed</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = a.<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">let</span> n = b.<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">let</span> lenM = m.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>) == -<span class="number">1</span> ? <span class="number">0</span> : m.<span class="property">length</span> - m.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> lenN = n.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>) == -<span class="number">1</span> ? <span class="number">0</span> : n.<span class="property">length</span> - n.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> len = <span class="title class_">Math</span>.<span class="title function_">max</span>(lenM,lenN)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(len)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (a*b).<span class="title function_">toFixed</span>(len)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个是先将其乘很多倍，然后算完再除回来。不过也要toFixed，效果差不多。</p><h1 id="第三十五题"><a href="#第三十五题" class="headerlink" title="第三十五题"></a>第三十五题</h1><h2 id="描述-24"><a href="#描述-24" class="headerlink" title="描述"></a>描述</h2><p>将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值</p><h2 id="示例1-20"><a href="#示例1-20" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alterContext(function() &#123;return this.greeting + &#x27;, &#x27; + this.name + &#x27;!&#x27;; &#125;, &#123;name: &#x27;Rebecca&#x27;, greeting: &#x27;Yo&#x27; &#125;)</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yo, Rebecca!</span><br></pre></td></tr></table></figure><p>记得之前好像有一个类似的题，应该是用apply之类的函数。</p><blockquote><p>在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数<br>fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">alterContext</span>(<span class="params">fn, obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="title function_">call</span>(obj,obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="第三十六题"><a href="#第三十六题" class="headerlink" title="第三十六题"></a>第三十六题</h1><h2 id="描述-25"><a href="#描述-25" class="headerlink" title="描述"></a>描述</h2><p>给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。</p><h2 id="示例1-21"><a href="#示例1-21" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var C = function(name) &#123;this.name = name; return this;&#125;; </span><br><span class="line">var obj1 = new C(&#x27;Rebecca&#x27;); </span><br><span class="line">alterObjects(C, &#x27;What\&#x27;s up&#x27;); obj1.greeting;</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What&#x27;s up</span><br></pre></td></tr></table></figure><p>做不来，直接看题解了。</p><blockquote><p>这是原型链问题。访问一个对象的方法或者是属性，首先会在该对象中寻找，如果找到则返回，如果没找到，则在其原型链上面向上寻找，直至基原型，如还未找到，则返回undefined。将<br>constructor 的所有实例的 greeting 属性指向给定的 greeting<br>变量，只需要在constructor的原型上面添加greeting属性，并指定值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">alterObjects</span>(<span class="params">constructor, greeting</span>) &#123;</span><br><span class="line">  constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greeting</span> = greeting;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="第三十七题"><a href="#第三十七题" class="headerlink" title="第三十七题"></a>第三十七题</h1><h2 id="描述-26"><a href="#描述-26" class="headerlink" title="描述"></a>描述</h2><p>找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)<br>1、返回数组，格式为 key: value<br>2、结果数组不要求顺序</p><h2 id="示例1-22"><a href="#示例1-22" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var C = function() &#123;this.foo = &#x27;bar&#x27;; this.baz = &#x27;bim&#x27;;&#125;; </span><br><span class="line">C.prototype.bop = &#x27;bip&#x27;; </span><br><span class="line">iterate(new C());</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;foo: bar&quot;, &quot;baz: bim&quot;]</span><br></pre></td></tr></table></figure><p>看来这几题都是原型链相关的</p><p>这就考察的是如何遍历一个对象的键值对。看完题解后知道，还需要借助hasOwnproperty函数判断是否是原型链上的属性，该函数在面对自己的属性时返回true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">iterate</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> arr = [];</span><br><span class="line">     <span class="comment">//使用for-in遍历对象属性</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">         <span class="comment">//判断key是否为对象本身的属性</span></span><br><span class="line">         <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">             <span class="comment">//将属性和值按格式存入数组</span></span><br><span class="line">             arr.<span class="title function_">push</span>(key+<span class="string">&quot;: &quot;</span>+obj[key]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="第三十八题"><a href="#第三十八题" class="headerlink" title="第三十八题"></a>第三十八题</h1><h2 id="描述-27"><a href="#描述-27" class="headerlink" title="描述"></a>描述</h2><p>给定字符串 str，检查其是否包含数字，包含返回 true，否则返回 false</p><h2 id="示例1-23"><a href="#示例1-23" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abc123&#x27;</span><br></pre></td></tr></table></figure><p>复制</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p>很c的想法，直接遍历每一个，然后判断是否是数字。</p><p>想要用typeof来判断是否是数字，但是失败了，因为逐个判断得到的是字符，所以不合适。</p><p>那么可以考虑进行一波ascii和字符的互相转换，这里了解一下</p><p>“A”.charCodeAt()转ascii</p><p>String.fromCharCode(num) , 转字符。</p><p>看题解得到更多是用正则来做的，这样确实更加优雅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">containsNumber</span>(<span class="params">str</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="regexp">/\d/</span>;</span><br><span class="line">     <span class="keyword">return</span> b.<span class="title function_">test</span>(str);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>至于js中的正则，交给明天吧。</p><h1 id="第三十九-四十三题"><a href="#第三十九-四十三题" class="headerlink" title="第三十九 - 四十三题"></a>第三十九 - 四十三题</h1><p>全是正则表达式的相关内容，统一交给明天。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 1）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day1/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为算法题实在太弱了，以前都还多少能写点算法题，现在就是纯纯的大废物一个。所以继续开始算法题的复健，大致分为两条线，一边是跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E5%8F%A6%E4%B8%80%E8%BE%B9%E6%98%AF%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，另一边是刷洛谷。</a></p><p>暂时分配时间为1周。看看效果如何（现在是4月25日，周一）。</p></blockquote><h2 id="七道链表题"><a href="#七道链表题" class="headerlink" title="七道链表题"></a>七道链表题</h2><h3 id="力扣21-「合并两个有序链表」"><a href="#力扣21-「合并两个有序链表」" class="headerlink" title="力扣21 「合并两个有序链表」"></a>力扣21 「合并两个有序链表」</h3><p>比较简单，直接根据节点的值的大小合并即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list1 || !list2)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="literal">NULL</span> ? list2 : list1; </span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * p1 = list1, *p2 = list2;</span><br><span class="line">        ListNode *head = (ListNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ListNode)),*temp = head;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)&#123;</span><br><span class="line">                temp-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1)&#123;</span><br><span class="line">            temp-&gt;next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2)&#123;</span><br><span class="line">            temp-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(head);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="力扣23-「合并k个有序链表」"><a href="#力扣23-「合并k个有序链表」" class="headerlink" title="力扣23 「合并k个有序链表」"></a>力扣23 「合并k个有序链表」</h3><p>试图按照刚才的方法去实现，发现会比较困难，<strong>每次要找到所有链表头处的最小值</strong>，如果直接遍历则时间复杂度较高。</p><p>于是看题解发现使用二叉堆来实现每次取最小值。</p><p>那这里就要涉及到在c++中，怎么去使用封装好的堆了。</p><h4 id="C-中的最小堆"><a href="#C-中的最小堆" class="headerlink" title="C++中的最小堆"></a>C++中的最小堆</h4><p>C++ 的 STL中的priority_queue是将优先级最大的放在队列的最前面，（底层）是最大堆，那怎么实现最小堆呢？ </p><p>下面的这个链接里给出了两种方法</p><p><a href="https://blog.csdn.net/nisxiya/article/details/45725857">https://blog.csdn.net/nisxiya/article/details/45725857</a></p><ul><li><p>符号重载（没看懂, 但是有来自妙妙的解释)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> v, <span class="type">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> v, <span class="type">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line"><span class="comment">//  friend bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2) ;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) ;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &gt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt; &gt; pq; <span class="comment">// 此时greater会调用 &gt; 方法来确认Node的顺序，此时pq是最小堆</span></span><br></pre></td></tr></table></figure><blockquote><p>建妙 刘, [4&#x2F;26&#x2F;22 8:40 AM]<br>[In reply to Ruoye Wu]<br>这个要明白C++ priority_queue的比较原理</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:41 AM]<br>本质上是 A operator B</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:41 AM]<br>如果为真，就把A放到B下面</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:41 AM]<br>重载小于号的是什么参数都没加</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:41 AM]<br>此时operator默认为&lt;</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:41 AM]<br>所以重载小于为数值比较就是大根堆</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:42 AM]<br>重载大于的那个是用了greater算子</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:42 AM]<br>用这个等于是把A operator B换成了 greater(A, B)</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:42 AM]<br>这个greater又是为了实现&gt;比较的一个类，里面调用了(node)A &gt; (node)B</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:43 AM]<br>所以等价于A operator 替换为了 A &gt; B</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:44 AM]<br>所以如果重载大于号为A &lt; B同样是大根堆，反之则是小根堆</p><p>建妙 刘, [4&#x2F;26&#x2F;22 8:45 AM]<br>所以，本质上就是，确定 A operator B的operator的符号，然后重载那个运算符为你想要的比较方法，即可</p></blockquote></li><li><p>定义cmp类，放在priority_queue中作为参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> idx;</span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">  <span class="built_in">node</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">idx</span>(a), <span class="built_in">key</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.key &gt; b.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure><p>这里就要提到重载小括号是啥意思了</p><p>原来是仿函数，或者叫函数对象，下面的链接说的很清楚</p><p><a href="https://blog.csdn.net/jinzhu1911/article/details/101317367i">https://blog.csdn.net/jinzhu1911/article/details/101317367i</a></p></li></ul><h4 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h4><p>那么知道了符号重载和最大堆最小堆了，这个时候可以考虑链表合并了。</p><p>写的时候发现，自己不知道优先队列的接口。</p><ul><li>top 访问队头元素</li><li>empty 队列是否为空</li><li>size 返回队列内元素个数</li><li>push 插入元素到队尾 (并排序)</li><li>emplace 原地构造一个元素并插入队列</li><li>pop 弹出队头元素</li><li>swap 交换内容</li></ul><p>然后写出了这个题，暂且先不考虑所谓的一题多解。先只是正常写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;lists.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="literal">NULL</span>)</span><br><span class="line">                a.<span class="built_in">push</span>(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode,*temp = head,*temp2;</span><br><span class="line">        <span class="keyword">while</span>(!a.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            temp2 = a.<span class="built_in">top</span>();</span><br><span class="line">            a.<span class="built_in">pop</span>();</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">            <span class="keyword">if</span>(temp2-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                a.<span class="built_in">push</span>(temp2-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="力扣19-「删除链表的倒数第N个节点」"><a href="#力扣19-「删除链表的倒数第N个节点」" class="headerlink" title="力扣19 「删除链表的倒数第N个节点」"></a>力扣19 「删除链表的倒数第N个节点」</h3><p>这个题写好几遍了，轻车熟路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *a = head, *b = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode *temp = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; b-&gt;val &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; a-&gt;val &lt;&lt; endl;</span><br><span class="line">        ListNode *temp = a-&gt;next;</span><br><span class="line">        a-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="力扣876-「链表的中间节点」"><a href="#力扣876-「链表的中间节点」" class="headerlink" title="力扣876 「链表的中间节点」"></a>力扣876 「链表的中间节点」</h3><p>龟兔赛跑，双指针，同轻车熟路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *a=head ,*b=head ;</span><br><span class="line">        <span class="keyword">while</span>(b-&gt;next!=<span class="literal">NULL</span> &amp;&amp; b-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">            b = b-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后面几题都是双指针变换。</p><h3 id="力扣160-「-相交链表」"><a href="#力扣160-「-相交链表」" class="headerlink" title="力扣160 「 相交链表」"></a>力扣160 「 <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a>」</h3><p>把两条链表一串，得到逻辑上的两条相同长度的链表，然后双指针走到相同时，表示存在相交。</p><h3 id="力扣141-与-力扣142「环形链表」"><a href="#力扣141-与-力扣142「环形链表」" class="headerlink" title="力扣141 与 力扣142「环形链表」"></a>力扣141 与 力扣142「环形链表」</h3><p>双指针龟兔赛跑判环。</p><p>如果要找环的起点，则在判到环的交叉处，令另一个节点从起点开始以相同速度继续运动，知道相遇，相遇点则是环起点。</p>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 10）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day10/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E7%AD%89%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E5%92%8C%E5%A4%A7%E8%87%B4%E5%A5%97%E8%B7%AF%E7%9F%A5%E9%81%93%E4%BA%86%EF%BC%8C%E5%86%8D%E5%8E%BB%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，等算法的思维和大致套路知道了，再去刷洛谷。</a></p></blockquote><h2 id="5-6补5-5"><a href="#5-6补5-5" class="headerlink" title="5.6补5.5"></a>5.6补5.5</h2><h3 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h3><p>做不来，看的题解，看完有两个问题：1.为什么在merge的时候每次加上不会重复计算？ 2.为什么能保证计算完全？</p><p>因为merge之后，比他小的数到左边去了，而在右边的数在计算一次以后，也到左边去了。想清楚以后觉得非常精妙。</p><p>在写归并排序的时候，出现了问题，一个是sort没有写递归出口，一个是merge的时候i和j没有自加。。。然后在vector的使用上出了点问题。</p><p>明明归并早就写好了，也一直有用，但是却始终得不到正确答案，因为在有重复数字时，出现哈希碰撞了。原来东哥的并不是用的哈系表实现的，而是通过pair来记录每个数字的位置。麻了。</p><p>也就是他的nums自带编号。</p><p>若是在没有重复数字的情况下，可以使用如下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b || a == b<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> mid = a + (b-a)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums,a,mid);</span><br><span class="line">        <span class="built_in">sort</span>(nums,mid,b);</span><br><span class="line">        <span class="built_in">merge</span>(nums,a,mid,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; nums,<span class="type">int</span> a, <span class="type">int</span> mid ,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        temp.<span class="built_in">assign</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = a, j = mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p = a; p&lt;b;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == mid)&#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j == b)&#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">                ans[mp[nums[p]]] += j - mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>( temp[i] &gt; temp[j])&#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">                ans[mp[nums[p]]] += j -mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">fill</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是有的时候是有重复数字的，所以不能直接用哈系表md。</p><p>但是c++里结构体好像赋值啥的都不方便。看一下力扣的题解吧（啥有用的都没有）。待会把符号重置回顾一下再说。</p><p>被归并排序打败了。。mark住，现在学不动这些题了。<a href="https://labuladong.github.io/algo/2/19/38/">https://labuladong.github.io/algo/2/19/38/</a></p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>先继续二叉树吧。。。</p><h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>中序遍历，没啥好说的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="type">int</span> K;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode * root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || !K) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        K--;</span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>)&#123;</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        K = k;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><p>自己摸索来摸索去，想了半天啥也没写对，试图利用所谓的返回值啦，参数啦来保存东西，其实只要一个全局变量就可以了。。。。</p><p>我真的服了，自己怎么这么菜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">traverse</span>(root) ;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><p>直接类似于二分即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right,val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right,val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TreeNode*root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;left,val);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;right,val);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="built_in">insert</span>(root,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题及就及进 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 11）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day11/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E7%AD%89%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E5%92%8C%E5%A4%A7%E8%87%B4%E5%A5%97%E8%B7%AF%E7%9F%A5%E9%81%93%E4%BA%86%EF%BC%8C%E5%86%8D%E5%8E%BB%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，等算法的思维和大致套路知道了，再去刷洛谷。</a></p></blockquote><h2 id="5-7补5-6"><a href="#5-7补5-6" class="headerlink" title="5.7补5.6"></a>5.7补5.6</h2><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p>在删的时候就遇到问题，就是在需要他的父节点的时候，如何删除他呢？</p><p>labuladong做的是将其作为返回值，在父递归上进行节点的连接。</p><p>c++和java的内存回收机制不一样，所以不能直接按照东的做法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getmin</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode*temp = <span class="built_in">getmin</span>(root-&gt;right);</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right,temp-&gt;val);</span><br><span class="line">            temp-&gt;left = root-&gt;left;</span><br><span class="line">            temp-&gt;right = root-&gt;right;</span><br><span class="line">            root = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; key)&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left,key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; key)&#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这个题C++的很少，没有找到专门设置了内存回收的。</p><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>简单了看了下题解，这种递归类问题，直接就是一个数组遍历，甚至还能再优化。但是已经是100%了，就算了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">21</span>];</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                a[i] += a[j]*a[i<span class="number">-1</span>-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h3><p>这个题就让人不得不去递归使用了。</p><p>写不来，看题解了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">traverse</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">      vector&lt;TreeNode*&gt; trees;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right;i++)&#123;</span><br><span class="line">          vector&lt;TreeNode*&gt; leftTrees = <span class="built_in">traverse</span>(left,i<span class="number">-1</span>);</span><br><span class="line">          vector&lt;TreeNode*&gt; rightTrees = <span class="built_in">traverse</span>(i+<span class="number">1</span>,right);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span>  ltree:leftTrees)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">auto</span> rtree:rightTrees)&#123;</span><br><span class="line">                  TreeNode * root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                  root-&gt;left = ltree;</span><br><span class="line">                  root-&gt;right = rtree;</span><br><span class="line">                  trees.<span class="built_in">push_back</span>(root);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> trees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traverse</span>(<span class="number">1</span>,n);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个主要是，利用定义？不过这种使用vector的递归确实用的很少。导致自己没有想到，但是写完其实还是蛮清晰的，就是遍历左右子树的所有可能性。唉，可惜自己想不到。</p><h3 id="912-排序数组（快排）"><a href="#912-排序数组（快排）" class="headerlink" title="912. 排序数组（快排）"></a><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a>（快排）</h3><p>真的，简单的快排，但是自己写还是失败了。</p><p>回忆起了严老师的超级优雅的快排，但是又没有完全回忆起，于是回顾了一下。真的超级优雅。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;  </span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">partition</span>(nums,left,right);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums,left,pos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(nums,pos+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">rand</span>() % i;</span><br><span class="line">            <span class="type">int</span> temp = nums[r];</span><br><span class="line">            nums[r] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">shuffle</span>(nums);</span><br><span class="line">       <span class="built_in">sort</span>(nums,<span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过在没有做随机化时，会超时，一定要随机化。</p>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题及就及进 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 10）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day12/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day12/</url>
      
        <content type="html"><![CDATA[<blockquote><p>跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E7%AD%89%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E5%92%8C%E5%A4%A7%E8%87%B4%E5%A5%97%E8%B7%AF%E7%9F%A5%E9%81%93%E4%BA%86%EF%BC%8C%E5%86%8D%E5%8E%BB%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，等算法的思维和大致套路知道了，再去刷洛谷。</a></p></blockquote><h2 id="5-6补5-5"><a href="#5-6补5-5" class="headerlink" title="5.6补5.5"></a>5.6补5.5</h2><h3 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h3><p>做不来，看的题解，看完有两个问题：1.为什么在merge的时候每次加上不会重复计算？ 2.为什么能保证计算完全？</p><p>因为merge之后，比他小的数到左边去了，而在右边的数在计算一次以后，也到左边去了。想清楚以后觉得非常精妙。</p><p>在写归并排序的时候，出现了问题，一个是sort没有写递归出口，一个是merge的时候i和j没有自加。。。然后在vector的使用上出了点问题。</p><p>明明归并早就写好了，也一直有用，但是却始终得不到正确答案，因为在有重复数字时，出现哈希碰撞了。原来东哥的并不是用的哈系表实现的，而是通过pair来记录每个数字的位置。麻了。</p><p>也就是他的nums自带编号。</p><p>若是在没有重复数字的情况下，可以使用如下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b || a == b<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> mid = a + (b-a)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums,a,mid);</span><br><span class="line">        <span class="built_in">sort</span>(nums,mid,b);</span><br><span class="line">        <span class="built_in">merge</span>(nums,a,mid,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; nums,<span class="type">int</span> a, <span class="type">int</span> mid ,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        temp.<span class="built_in">assign</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = a, j = mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p = a; p&lt;b;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == mid)&#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j == b)&#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">                ans[mp[nums[p]]] += j - mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>( temp[i] &gt; temp[j])&#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">                ans[mp[nums[p]]] += j -mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mp[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">fill</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是有的时候是有重复数字的，所以不能直接用哈系表md。</p><p>但是c++里结构体好像赋值啥的都不方便。看一下力扣的题解吧（啥有用的都没有）。待会把符号重置回顾一下再说。</p><p>被归并排序打败了。。mark住，现在学不动这些题了。<a href="https://labuladong.github.io/algo/2/19/38/">https://labuladong.github.io/algo/2/19/38/</a></p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>先继续二叉树吧。。。</p><h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>中序遍历，没啥好说的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="type">int</span> K;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode * root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || !K) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        K--;</span><br><span class="line">        <span class="keyword">if</span>(K==<span class="number">0</span>)&#123;</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        K = k;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><p>自己摸索来摸索去，想了半天啥也没写对，试图利用所谓的返回值啦，参数啦来保存东西，其实只要一个全局变量就可以了。。。。</p><p>我真的服了，自己怎么这么菜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">traverse</span>(root) ;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><p>直接类似于二分即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right,val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right,val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TreeNode*root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;left,val);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;right,val);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="built_in">insert</span>(root,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题及就及进 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 2）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day2/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为算法题实在太弱了，以前都还多少能写点算法题，现在就是纯纯的大废物一个。所以继续开始算法题的复健，大致分为两条线，一边是跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E5%8F%A6%E4%B8%80%E8%BE%B9%E6%98%AF%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，另一边是刷洛谷。</a></p><p>暂时分配时间为1周。看看效果如何（现在是4月26日，周二）。</p></blockquote><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="力扣-206-「反转链表」"><a href="#力扣-206-「反转链表」" class="headerlink" title="力扣 206 「反转链表」"></a>力扣 206 「反转链表」</h3><p>能一遍写出来的简单题，普通版没啥好解释的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * temp = head, *next = head-&gt;next,*last = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">            next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = last;</span><br><span class="line">            last = temp;</span><br><span class="line">            temp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是听说有递归版，简单思考一下递归版应该怎么写。</p><p>自己在写的时候，想要让递归返回结果是为尾节点，然后发现最后没的返回头节点了，看了题解以后，发现其实head-&gt;next指向的就是尾节点，所以让返回值是头节点才更合适。</p><p>递归确实看着比循环要优雅的多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode * a = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="力扣92-「反转链表II」"><a href="#力扣92-「反转链表II」" class="headerlink" title="力扣92 「反转链表II」"></a>力扣92 「反转链表II」</h3><p>这个借助题解的思路跌跌撞撞写了一个ac的，但是感觉这个代码不够优雅，存在特判。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *successor = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next== <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            successor = head-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode * a= <span class="built_in">reverse</span>(head-&gt;next, num - <span class="number">1</span>);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = successor;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode * temp = head,*a;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; left - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">            a = <span class="built_in">reverse</span>(temp,right);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            temp-&gt;next = <span class="built_in">reverse</span>(temp-&gt;next,right - i); </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了下题解，把第二个函数也递归了，于是显得更加优雅。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head,right);</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next,left<span class="number">-1</span>,right<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实更加优雅，但是也带来了更多的空间消耗，因为此处其实只要遍历就能把left用掉，而使用递归的话，则使用了更多函数调用，导致更多的空间消耗也很合理。</p><h3 id="力扣-25-「k个一组反转链表」"><a href="#力扣-25-「k个一组反转链表」" class="headerlink" title="力扣 25 「k个一组反转链表」"></a>力扣 25 「k个一组反转链表」</h3><p>这显然是一个递归问题，题解用的迭代法，我先用递归写一份。</p><p>写出来了，太感动了属于是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    ListNode * successor;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span> &amp;&amp; head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            successor = head-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *a = <span class="built_in">reverse</span>(head-&gt;next,k<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = successor;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *a = <span class="built_in">reverse</span>(head,k);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="built_in">reverseKGroup</span>(successor,k);</span><br><span class="line">        <span class="keyword">return</span> a;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="力扣234「判断回文字符串」"><a href="#力扣234「判断回文字符串」" class="headerlink" title="力扣234「判断回文字符串」"></a>力扣234「判断回文字符串」</h3><p>正常思路，遍历一遍存进栈中，再重新跑链表并且出栈，比较是否相同， 虽然空间复杂度O(n),但是我觉得已经ok了。对于机试已经ok了。</p><p>故此处略。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>（一下题目都是一眼不能想到暴力的题目）</p><h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h3><p>题目中所说的子数组应该是指连续的子数组（由样例得到）</p><p>使用刚才学到的前缀和的思想。然后直接进行一个暴力穷举，然后超时了。寄。</p><p>看题解有说，可以再哈系表一波，降时间复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>,pre= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x:nums)&#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                count += mp[pre-k]; </span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的时间复杂度和空间复杂度都不算高，特别是直接把前缀和的哈系表运算和统计放在了一个for循环中，一般来说是比较难想到的，非常优雅。</p><h3 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h3><p>刚学完的差分表方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; bookings, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bookings.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            a[bookings[i][<span class="number">0</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            a[bookings[i][<span class="number">1</span>]] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto &amp; a1:a)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;a1&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answer</span><span class="params">(n)</span></span>;</span><br><span class="line">        answer[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;n;i++)&#123;</span><br><span class="line">            answer[i] = a[i] + answer[i<span class="number">-1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h3><p>正常的双指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="type">int</span> last= <span class="number">0x12332421</span>;</span><br><span class="line">        left = <span class="number">0</span>;right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] != last)&#123;</span><br><span class="line">                last = nums[right];</span><br><span class="line">                nums[left++] = nums[right];</span><br><span class="line">            &#125; </span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]!=val)&#123;</span><br><span class="line">                nums[left++] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 3）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day3/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为算法题实在太弱了，以前都还多少能写点算法题，现在就是纯纯的大废物一个。所以继续开始算法题的复健，大致分为两条线，一边是跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E5%8F%A6%E4%B8%80%E8%BE%B9%E6%98%AF%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，另一边是刷洛谷。</a></p><p>暂时分配时间为1周。看看效果如何（现在是4月27日，周三）。</p></blockquote><h2 id="二维数组的花式遍历"><a href="#二维数组的花式遍历" class="headerlink" title="二维数组的花式遍历"></a>二维数组的花式遍历</h2><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h3><p>原地修改的，直接看的题解，先根据左上到右下对称，然后每行逆序，就相当于顺时针90度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n  = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i ; j++)&#123;</span><br><span class="line">                <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(matrix[i].<span class="built_in">begin</span>(),matrix[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h3><p>上下左右四个边界的边界思想。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> up = <span class="number">0</span>, down = m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="built_in">size</span>() &lt; m*n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(up &lt;= down)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt;= right;i++)&#123;</span><br><span class="line">                    a.<span class="built_in">push_back</span>(matrix[up][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                up++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i =up; i &lt;= down; i++)&#123;</span><br><span class="line">                    a.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(up &lt;= down)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = right; i &gt;=left; i--)&#123;</span><br><span class="line">                    a.<span class="built_in">push_back</span>(matrix[down][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                down--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = down; i&gt;=up; i--)&#123;</span><br><span class="line">                    a.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 4）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day4/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为算法题实在太弱了，以前都还多少能写点算法题，现在就是纯纯的大废物一个。所以继续开始算法题的复健，大致分为两条线，一边是跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E5%8F%A6%E4%B8%80%E8%BE%B9%E6%98%AF%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，另一边是刷洛谷。</a></p><p>暂时分配时间为1周。看看效果如何（现在是4月28日，周四）。</p><p>今天一天，摸了鱼，看了保研&#x2F;出国资讯，刷了很多乱七八糟的信息，甚至聚了餐，准备了明天的习概考试，还练了会儿吉他，除了算法啥别的事都干了属于是。</p></blockquote><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><p>看起来逻辑非常简单，但是写的时候其实是容易出错的，因为时间关系对着题解写的，但是还是出现了问题，此类题目边界处理等等非常重要。</p><p>此处主要是一个valid这种思想，我不太能想到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need, window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)&#123;</span><br><span class="line">            need[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; len)&#123;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(need[d] == window[d])&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125; </span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> len == INT_MAX? <span class="string">&quot;&quot;</span> :s.<span class="built_in">substr</span>(start,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h2><p>蚌埠住了，和上一提几乎一模一样，就是收缩的条件不同，但是我还是做错了很久。快要没时间写第三题了啊喂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mp1,mp2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s1)&#123;</span><br><span class="line">            mp1[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> d = s2[right];</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mp1.<span class="built_in">count</span>(d))&#123;  <span class="comment">// 需要的</span></span><br><span class="line">                mp2[d]++;</span><br><span class="line">                <span class="keyword">if</span>(mp2[d] == mp1[d])&#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(right - left &gt;= s1.<span class="built_in">size</span>())&#123;  <span class="comment">// 需要收缩了</span></span><br><span class="line">                <span class="keyword">if</span>(valid == mp1.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> c = s2[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(mp1.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp1[c] == mp2[c])&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mp2[c]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><p>自信提交，背板子yyds</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; need,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:p)&#123;</span><br><span class="line">            need[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> vaild = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                    vaild++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(vaild == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left == p.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(need[d] == window[d])&#123;</span><br><span class="line">                        vaild--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用labuladong的算法小抄刷算法题（day 6）</title>
      <link href="/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day6/"/>
      <url>/2022/08/01/%E5%88%B7%E7%AE%97%E6%B3%95day6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为算法题实在太弱了，以前都还多少能写点算法题，现在就是纯纯的大废物一个。所以继续开始算法题的复健，大致分为两条线，一边是跟着labuladong(<a href="https://labuladong.github.io/algo/)%E5%88%B7%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8C%E5%8F%A6%E4%B8%80%E8%BE%B9%E6%98%AF%E5%88%B7%E6%B4%9B%E8%B0%B7%E3%80%82">https://labuladong.github.io/algo/)刷算法基础，另一边是刷洛谷。</a></p><p>暂时分配时间为1周。看看效果如何（现在是4月30日，周六）。</p><p>昨天一天很充实也很摆烂，没有写算法题，等于说是今天直接就day6了。难顶。</p></blockquote><h2 id="补day4的滑窗"><a href="#补day4的滑窗" class="headerlink" title="补day4的滑窗"></a>补day4的滑窗</h2><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; window;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;         </span><br><span class="line">                <span class="comment">//cout &lt;&lt; left&lt;&lt;&#x27;,&#x27;&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res,right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为之前把滑窗又给忘了，所以回顾了一下之前做的几道滑窗问题，终于捡回来了。</p><p>中午12：50,已经是不想学习的状态了。</p><p>5月2日补</p><h2 id="二分专题"><a href="#二分专题" class="headerlink" title="二分专题"></a>二分专题</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p>直接写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>跟着题解跌跌撞撞的写出来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() <span class="number">-1</span> ;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123; <span class="comment">// 先找左</span></span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid <span class="number">-1</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == nums.<span class="built_in">size</span>() || nums[left] != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">// 不知道这个怎么返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans.<span class="built_in">push_back</span>(left);</span><br><span class="line"></span><br><span class="line">        left = left,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="528-按权重随机选择"><a href="#528-按权重随机选择" class="headerlink" title="528. 按权重随机选择"></a><a href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></h3><p>这个题，前缀和 + 二分法</p><p>自己写完最后两个样例过不了，但是仔细看了下应该也没有啥问题，所以就不贴代码了。。。。。</p><p>（因为题解不写人话，全是stl）</p><p>但是前缀和+二分法在轮盘赌中好像也有应用。</p><h3 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></h3><p>看完题目暂时还没得想到和二分法的关系。看labuladong竟然要收费。。。。</p><p>直接看力扣题解好了。</p><p>看完题解发现其实就是一个遍历，直接一个个遍历会时间复杂度太高，所以使用二分进行遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span> , right = <span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>);</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,piles,h))&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt;&amp; piles,<span class="type">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> pile:piles)&#123;</span><br><span class="line">            sum += (pile - <span class="number">1</span>) / x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt;= h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之前一直觉得会有什么妙解，但是其实就只是简单的模拟，然后用二分法加速了。</p><h3 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></h3><p>二分的思维是有了，但是模拟的时候模拟错了，甚至想要用前缀和，滑窗去模拟，其实非常简单直接模拟就行，简单的模拟+二分即可。</p><p>这题我遍历了一遍数组获得左右边界。stl里是有语法糖的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = *<span class="built_in">max_element</span>(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> right = <span class="built_in">accumulate</span>(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>像他这样就会少写几行代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; weights, <span class="type">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> big = weights[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> sum = weights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weights.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            big = <span class="built_in">max</span>(big, weights[i]);</span><br><span class="line">            sum += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = big, right = sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(weights,days,mid))&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;weights,<span class="type">int</span> days, <span class="type">int</span> x)</span></span>&#123; </span><br><span class="line">        <span class="type">int</span> temp = x;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w:weights)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp - w &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                temp -= w;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = x;</span><br><span class="line">                temp -= w;</span><br><span class="line">                now++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now &lt;= days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h3><p>这是一道困难题。这个题自己没能写出来，看题解也反复斟酌了一会才知道到底是啥意思。</p><p>首先这个题是可以用动规做的，但是不想用动规（因为还没开始专门刷动规），然后看题解发现可以用二分。</p><p>这里用二分我是有一个疑惑的，就是，凭什么可以直接认定这种方法可以找到子数组的和的最大值的最小且分成m个子数组？</p><p>在看了几篇文章后发现了一个讲解</p><p><img src="/home/blues/Desktop/blog/source/_posts/%E5%88%B7%E7%AE%97%E6%B3%95day6/image-20220502145816330.png" alt="image-20220502145816330"></p><p>然后才明白为什么可以直接用二分得到正确答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()), right = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; left &lt;&lt; &#x27;,&#x27;&lt;&lt;right;</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left+(right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(nums,m,mid))&#123;</span><br><span class="line">                right = mid <span class="number">-1</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left  = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> m, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + num &gt; x)&#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 给我刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/01/hello-world/"/>
      <url>/2022/08/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo + github page配置个人博客</title>
      <link href="/2022/08/01/hexo%20+%20github%20page%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/08/01/hexo%20+%20github%20page%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前其实配置过个人博客，甚至还折腾过更加适合自己的主题，但是后来在进行硬盘更新的时候，面对着大量没啥含金量的“黑历史博客”，最终还是决定不对其进行备份了。</p><p>但是总感觉生活是需要记录的，于是今天，重振旗鼓，重新来折腾hexo啦。顺便记录下这次操作。时隔快两年。大多数当时看不懂的命令都已经无比熟悉啦。</p></blockquote><p>之前是参照着知乎上的专栏完成的，所以很多工作如创建一个github的repo等之前已经完成过了，这里就没有重复。详情可以看链接。</p><p><a href="https://www.zhihu.com/column/c_1201860091307458560">https://www.zhihu.com/column/c_1201860091307458560</a></p><p>本文章单纯写着记录，可能并没有太大参照价值。前半部分都是在对着官网文档<a href="https://hexo.io/zh-cn/docs/%E8%87%AA%E8%AF%B4%E8%87%AA%E8%AF%9D%EF%BC%88%E8%87%B3%E5%B0%91%E5%9C%A8%E5%AE%89%E8%A3%85%E5%88%B0%E9%83%A8%E7%BD%B2%E8%BF%99%E5%87%A0%E6%AD%A5%E6%B2%A1%E6%9C%89%E5%8F%82%E7%85%A7%E4%BB%B7%E5%80%BC%EF%BC%8C%E4%BD%86%E6%98%AF%E5%90%8E%E9%9D%A2%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E5%88%86%E5%80%92%E6%98%AF%E8%87%AA%E5%B7%B1%E5%9C%A8%E6%8A%98%E8%85%BE%EF%BC%89">https://hexo.io/zh-cn/docs/自说自话（至少在安装到部署这几步没有参照价值，但是后面的自定义部分倒是自己在折腾）</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>打开官网直接安装就行（需要有node.js环境）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>按照上面的命令，访问localhost:4000就能直接访问页面了。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在配置页观察了一下，对于我来说暂时先按照默认配置即可。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p></blockquote><h3 id="模板（scaffold）"><a href="#模板（scaffold）" class="headerlink" title="模板（scaffold）"></a>模板（scaffold）</h3><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件建立日期</td></tr></tbody></table><p>感觉官网上这一段话没有说清楚。看完觉得好像是表示可以直接把文件放在scaffold中然后能根据此生成页面。待会儿深究。</p><h3 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h3><p>之前在用某些主题的时候，渲染代码块等内容时如果出现flask或者django中的双大括号，大括号+百分号时，会出现渲染的错误，原来是因为hexo自带了标签插件啊。</p><p>不过个人认为，不是到了必须用的时候，还是尽量不使用标签插件，私有意味着不兼容，毕竟大部分文章都是typora写的，总不能上面都是丑丑的吧。</p><hr><p>（以下内容都是直接复制的官网）</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><p>在静态模式下，服务器只处理 <code>public</code> 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 <code>hexo generate</code>，此模式通常用于生产环境（production mode）下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -s</span><br></pre></td></tr></table></figure><h4 id="自定义-IP"><a href="#自定义-IP" class="headerlink" title="自定义 IP"></a>自定义 IP</h4><p>服务器默认运行在 <code>0.0.0.0</code>，您可以覆盖默认的 IP 设置，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -i 192.168.1.1</span><br></pre></td></tr></table></figure><p>指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的<code>127.0.0.1</code>外，通常还有一个<code>192.168.*.*</code>的局域网IP，如果像上面那样使用<code>-i</code>参数，就不能用<code>127.0.0.1</code>来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为<code>-i</code>参数的值，那么就无法通过公网来访问站点。</p><h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><p>使用 Hexo 生成静态文件快速而且简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h4 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h4><p>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --watch</span><br></pre></td></tr></table></figure><h4 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h4><p>您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --deploy</span><br><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure><blockquote><p>简写</p><p>上面两个命令可以简写为<br>$ hexo g -d<br>$ hexo d -g</p></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>直接选择一键部署。</p><p>安装hexo-deployer-git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后_config.yml的配置中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>但是此处的repo的地址，需要结合你的认证方式，因为github已经取消了密码验证了，所以这里我选择用ssh验证，链接就是git开头的，比如我的就是这下面这个。</p><p><code>git@github.com:blue-vegetable/blue-vegetable.github.io.git</code></p><p>然后运行hexo deploy即可部署至github上。</p><p>直接访问自己的github page即可看到。</p><p>https:&#x2F;&#x2F;你的github名.github.io&#x2F;</p><p>比如<a href="https://blue-vegetable.github.io/">https://blue-vegetable.github.io/</a></p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>在下面的链接中找到喜欢的主题</p><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p>看到一个很vue的主题<a href="https://garybear.cn/hexo-theme-insulin/#/%EF%BC%8C">https://garybear.cn/hexo-theme-insulin/#/，</a> 以后要是当助教啥的，可以用这个做课程FAQ啥的。</p><p>好多主题都缩略图和里面不符hhh，也有很多都已经打不开网页了。</p><p>配合着github，找了很多主题，有些在配置时就有明显的问题，出现报错等等，所以说，找主题也不是一件简单的事。。。</p><p>找到了一个个人觉得很好的主题，链接如下所示。</p><p><a href="https://github.com/yuang01/hexo-theme-bamboo">https://github.com/yuang01/hexo-theme-bamboo</a></p><p>按照readme里的内容进行配置即可。非常简单，然后就可以看到页面已经是想要的主题了 。</p><h3 id="主题的修改"><a href="#主题的修改" class="headerlink" title="主题的修改"></a>主题的修改</h3><p>主题中有很多已有但不是我想要的内容，所以就要改他了。</p><p>那么这个主题有自己的官方文档<a href="https://yuang01.gitee.io/">https://yuang01.gitee.io/</a></p><p>根据他的文档就可以修改了。</p><p>基本围绕着主题目录下的_config.yml就万事，把该关的功能和自定义的文本改好了就好啦。</p><h2 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h2><p>因为通常我都是已经写好markdown文件的，所以只需要将markdown文件复制到 source&#x2F;_posts&#x2F; 中，然后参照着helloworld.md 添加一个title即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 12323121</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
